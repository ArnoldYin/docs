---

copyright:
  years: 2016, 2017
lastupdated: 2017-03-16

---

{:shortdesc: .shortdesc}
{:new_window: target=_blank}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# Function as a Service (FaaS) im Vergleich
{: #openwhisk_faas_compared}

Die serverunabhängige Architektur (Serverless Architecture) ist kein Heilmittel für alle Datenverarbeitungsprobleme, aber sie löst einige von ihnen. Es gibt zahlreiche [Anwendungsfälle](./openwhisk_use_cases.html), in denen das serverunabhängige Design eine gute Wahl darstellt. In diesem Abschnitt sollen die folgenden Architekturen verglichen werden: 

1. **Function as a Service (FaaS)** - verwaltetes OpenWhisk. Gegenwärtig ist IBM der einzige Anbieter für verwaltetes [OpenWhisk on Bluemix](https://console.ng.bluemix.net/openwhisk).

2. **Infrastructure as a Service (IaaS)** mit OpenWhisk Roll Your Own (RYO). Endbenutzer können OpenWhisk von Apache Incubation Project herunterladen und in [Bluemix IaaS](https://console.ng.bluemix.net/catalog/?category=devices) oder einer anderen [IaaS-Cloud](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29) installieren und ausführen. 

3. **Platform as a Service (PaaS)** - verwaltete Anwendungslaufzeit. Ein gutes Beispiel für diese Architektur ist die [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java)-Laufzeit, die von der IBM Bluemix-CloudFoundry-Implementierung verwaltet wird.

4. **Container as a Service (CaaS)** - verwaltete Containerumgebung. Ein gutes Beispiel ist [Containers on Bluemix](https://console.ng.bluemix.net/catalog/?category=containerImages) von IBM. 

5. **Infrastructure as a Service (IaaS)** mit Java EE-Laufzeit. Ein gutes Beispiel ist [WebSphere Application Server VM on Bluemix](https://console.ng.bluemix.net/catalog/services/websphere-application-server) von IBM. 

In der folgenden Übersicht werden die Vor- und Nachteile der einzelnen Architekturoptionen aus der **Perspektive eines Endbenutzers** zusammengefasst, der Anwendungen in diesen unterschiedlichen Laufzeiten entwickelt und betreibt:


| Thema | (1) OpenWhisk FaaS | (2) OpenWhisk RYO | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	Anwendungseinheit	|	Einzelne Funktion (in der Regel ein kleiner Codeblock in einem JavaScript-, Swift- oder Docker-Container) - kann kleiner als 1 KB oder auch größer sein. Meist nicht mehr als wenige KB.	|	Wie Spalte (1)	|	Abhängig von der verwendeten Laufzeit - könnte eine EAR- oder WAR-Datei oder ein anderes sprachspezifisches Anwendungsbundle sein, meist relativ groß - KB oder sogar MB mit vielen Services in einem Bundle, oder aber auch nur so groß wie einzelner Service.	|	Docker-Container ist die Bereitstellungseinheit.	|	VM mit App-Server mit EAR- oder WAR-Datei und anderen Abhängigkeiten - Größe meist im GB-Bereich.	|
|	Ressourcenbedarf	|	Endbenutzer braucht Hauptspeicher, CPU-Kapazität oder andere Ressourcen nicht zu bezahlen und nicht dafür zu sorgen. Obwohl die Aktion einen Bedarf hat, muss sich der Benutzer nicht darum kümmern. 	|	Hoch. Endbenutzer muss zuerst eine IaaS-Umgebung bereitstellen und anschließend OpenWhisk darin installieren und konfigurieren. 	|	Gering. Endbenutzer bezahlen Speicher und CPU für die Ausführung von Apps, jedoch nichts für Apps, die nicht ausgeführt werden.	|	Gering bis mittel.	|	Hoch. Endbenutzer muss für Plattenspeicher, Hauptspeicher, CPUs und mögliche andere Komponenten zahlen, wenn die App ausgeführt wird. Wenn sie gestoppt ist, entstehen nur Speicherkosten.	|
|	Installation und Einrichtung	|	Keine erforderlich.	|	Aufwendig - erfolgt alles durch Endbenutzer.	|	Keine erforderlich.	|	Moderat - Hardware, Vernetzung, Betriebssystem, Tools für Container-Management durch CaaS-Anbieter bereitgestellt; Images, Konnektivität und Instanzen durch Endbenutzer.	|	Aufwendig - Hardware, Vernetzung, Betriebssystem, Java EE-Erstinstallation durch Anbieter; zusätzliche Konfiguration, Clustering, Skalierung durch Endbenutzer.	|
|	Bereitstellungszeit	|	Millisekunden	|	Siehe Spalten (4) und (5).	|	Minuten	|	Minuten	|	Stunden	|
|	Fortlaufende Verwaltung	|	Keine	|	Aufwendig	|	Keine	|	Moderat	|	Aufwendig	|
|	Elastisches Skalieren	|	Jede Aktion wird immer sofort und inhärent abhängig von der Last skaliert. Es ist nicht erforderlich, VMs oder andere Ressource im Voraus bereitzustellen.	|	Nicht bereitgestellt - Endbenutzer muss Rechnerkapazität auf IaaS-Plattform bereitstellen und die Skalierung von VMs verwalten. Wenn VMs skaliert wurden, skaliert OpenWhisk eine Aktion automatisch, jedoch muss die Ressource im Voraus bereitgestellt werden.	|	Automatische, jedoch langsame Skalierung. Zu Beginn einer Lastspitzenphase von mehreren Minuten müssen Benutzer möglicherweise auf die Ausführung der Skalieraktion warten. Automatisches Skalieren erfordert sorgfältige Optimierung.	|	Automatische, jedoch langsame Skalierung. Zu Beginn einer Lastspitzenphase von mehreren Minuten müssen Benutzer möglicherweise auf die Ausführung der Skalieraktion warten. Automatisches Skalieren erfordert sorgfältige Optimierung.	|	Nicht bereitgestellt.	|
|	Kapazitätsplanung	|	Nicht erforderlich. FaaS stellt automatisch die erforderliche Kapazität bereit.	|	Bereitstellung ausreichender Kapazität im Voraus erforderlich oder durch ein Script.	|	Einige Kapazitätsplanung erforderlich, aber eine automatische Funktion zur Kapazitätserhöhung wird bereitgestellt.	|	Einige Kapazitätsplanung erforderlich, aber eine automatische Funktion zur Kapazitätserhöhung wird bereitgestellt.	|	Statische Bereitstellung ausreichender Kapazität zum Auffangen †von Spitzenlasten erforderlich.	|
|	Persistente Verbindungen und Status	|	Sehr begrenzt - kann keine persistente Verbindung außer beim Container-Caching aufrechterhalten. Allgemein muss der Status in einer externen Ressource verwaltet werden.	|	Wie Spalte (1)	|	Wird unterstützt - kann ein offenes Socket oder eine Verbindung über lange Zeit behalten, kann den Status zwischen Aufrufen im Arbeitsspeicher speichern.	|	Wird unterstützt - kann ein offenes Socket oder eine Verbindung über lange Zeit behalten, kann den Status zwischen Aufrufen im Arbeitsspeicher speichern.	|	Wird unterstützt - kann ein offenes Socket oder eine Verbindung über lange Zeit behalten, kann den Status zwischen Aufrufen im Arbeitsspeicher speichern.	|
|	Wartung	|	Nicht erforderlich - gesamter Stack wird von IBM verwaltet.	|	Erheblich - abhängig von der Zielumgebung muss der Benutzer für Hardware, Vernetzung, Betriebssysteme, Speicher, Datenbankressourcen, Installation und Wartung von OpenWhisk usw. sorgen.	|	Nicht erforderlich - gesamter Stack wird vom Anbieter verwaltet.	|	Erheblich - Benutzer muss angepasste †Images erstellen und verwalten, Container bereitstellen und verwalten, Verbindungen zwischen Containern verwalten usw.	|	Erheblich - Benutzer muss VMs zuordnen, Java EE-Server einzeln verwalten und skalieren.	|
|	High Availability (HA - Hochverfügbarkeit) und Disaster Recovery (DR)	|	Inhärent / keine Zusatzkosten	|	Roll Your Own (RYO) 	|	Gegen Zusatzgebühr verfügbar	|	Ausgefallene Container können automatisch erneut gestartet werden.	|	Gegen Zusatzgebühr verfügbar, halbautomatisch. VMs können automatisch von anderen Ressourcen übernommen werden (Failover).	|
|	Sicherheit	|	Vom Anbieter bereitgestellt	|	Roll Your Own (RYO)	|	Mischung aus RYO und Anbieterleistung	|	Mischung aus RYO und Anbieterleistung	|	Roll Your Own (RYO)	|
|	Geschwindigkeit für Entwickler	|	Sehr hoch	|	Sehr hoch	|	Sehr hoch	|	Durchschnittlich	|	Langsam	|
|	Auslastung von Ressourcen (inaktive Ressourcen, für die gezahlt werden muss)	|	Ressourcen sind nie inaktiv, da sie nur auf Anforderung aufgerufen werden. Bei keiner Arbeitslast gibt es keine Ressourcenzuordnung und keine Kosten.	|	Da diese Option mit IaaS oder CaaS arbeitet, gilt Ähnliches wie in den Spalten (4) und (5). 	|	Einige Ressourcen können inaktiv sein. Automatisches Hoch- oder Herunterskalieren hilft, inaktive Ressourcen zu vermeiden, jedoch müssen einige aktive Instanzen immer vorhanden sein und diese werden wahrscheinlich zu weniger als 50% ihrer Kapazität ausgelastet. Gestoppte Instanzen kosten nichts.	|	Ähnlich wie Spalte (3)	|	Einige Ressourcen können inaktiv sein. Automatisches Skalieren wird nicht unterstützt. Einige aktive Instanzen müssen immer vorhanden sein und diese werden wahrscheinlich zu weniger als 50% ihrer Kapazität ausgelastet. Für gestoppte Instanzen können Kosten für Speicher anfallen.	|
|	Reife	|	Früher Reifegrad.	|	Früher Reifegrad.	|	Früher Reifegrad.	|	Mittlerer Reifegrad.	|	Sehr ausgereift.	|
|	Ressourcengrenzen	|	[Einige Begrenzungen gelten.](./openwhisk_reference.html#openwhisk_syslimits)	|	Abhängig von zugeordneten Ressourcen.	|	Nein	|	Nein	|	Nein	|
|	Latenz für selten genutzte Services	|	Seltene Anforderungen können zu Anfang mit einigen Sekunden Antwortzeit verbunden sein, was sich jedoch im Millisekundenbereich für nachfolgende Anforderungen bewegt.	|	Jeweils abhängig.	|	Sehr gering.	|	Sehr gering.	|	Sehr gering - sofern das System über ausreichend Ressourcen verfügt.	|
|	Optimaler Anwendungstyp	|	Ereignisverarbeitung, Internet der Dinge, Mobile-Back-End, Microservices. Definitiv nicht für große Gesamtanwendungen. Siehe [Anwendungsfälle](./openwhisk_use_cases.html).	|	Wie in Spalte (1), jedoch wenn der Benutzer in einer anderen Cloud als IBM Cloud oder lokal (On-Premises) arbeiten möchte.	|	Webanwendungen mit 24x7-Auslastung, statusabhängige Services, die die Verbindung über lange Zeiträume offen halten müssen. Geeignet zur Ausführung von Microservices oder großer Gesamtanwendungen.	|	Gut geeignet für Microservice-Anwendungen.	|	Traditionelle Unternehmensanwendungen, die aus lokalen Umgebungen in die Cloud migriert wurden. Besser geeignet für große Gesamtanwendungen.	|
|	Gebührenaufteilung und Abrechnung	|	[Pro Block von 100 Millisekunden](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	Abhängig von der Implementierung - wenn mit Verwendung von IaaS oder CaaS, gilt Ähnliches wie für die Spalten (4) und (5).	|	In der Regel Gebühr auf Stundenbasis (selten pro Minute) für ein Ressourcenpaket (CPU + Arbeitsspeicher + Plattenspeicher).	|	Ähnlich wie Spalte (3)	|	Ähnlich wie Spalte (3)	|
|	Anschaffungs- und Betriebskosten (TCO)	|	Bei Verwendung für optimal geeignete Anwendungen liegt die Größenordnung der Gebühren sehr wahrscheinlich unter der der Alternativen. Aufgrund der automatischen Ressourcenskalierung gibt es kein Problem mit Überkapazitäten.	|	Für Cloudbereitstellungen ist dies wahrscheinlich teurer als OpenWhisk FaaS, kann für eine lokale Bereitstellung (On-Premises) jedoch günstiger als traditionelle Architekturen sein.	|	Relativ gering - der Benutzer muss keine Ressourcen bereitstellen oder verwalten, sondern muss sich nur um seine Anwendung kümmern, jedoch ist im Vergleich zu Serverless eine gewisse Überbereitstellung möglich.	|	Moderat - der Benutzer muss Container und Anwendung bereitstellen und verwalten, jedoch besteht im Vergleich zu Serverless und PaaS eine gewisse Überbereitstellung.	|	Relativ hoch, jedoch in Anbetracht der möglicherweise sehr hohen Kosten für die Migration der traditionellen Anwendungen auf ein natives Cloudmodell kann dies ein durchaus gangbarer und ökonomischer Weg für die betreffenden Apps sein.	|
