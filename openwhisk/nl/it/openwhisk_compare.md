---

copyright:
  years: 2016, 2017
lastupdated: 2017-04-26

---

{:shortdesc: .shortdesc}
{:codeblock: .codeblock}
{:screen: .screen}
{:pre: .pre}

# FaaS (Function as a Service) - Confronto
{: #openwhisk_faas_compared}

L'architettura senza server non è una panacea per tutti i problemi di calcolo, ma ne risolve alcuni. Esistono [molti casi di utilizzo](./openwhisk_use_cases.html) in cui la progettazione senza server può essere una buona scelta. Qui confronteremo le seguenti architetture:

1. **FaaS (Function as a Service)** - gestita da OpenWhisk. Al momento IBM è l'unico fornitore che offre [OpenWhisk su Bluemix](https://console.ng.bluemix.net/openwhisk) gestito.

2. **IaaS (Infrastructure as a service)** con RYO (Roll Your Own) OpenWhisk. Gli utenti finali possono scaricare OpenWhisk da Apache Incubation Project installarlo ed eseguirlo in [IaaS Bluemix](https://console.ng.bluemix.net/catalog/?category=devices) o su altro [Cloud IaaS](https://en.wikipedia.org/wiki/Cloud_computing#Infrastructure_as_a_service_.28IaaS.29).

3. **PaaS (Platform as a Service)** - runtime dell'applicazione gestito. Un buon esempio è [Liberty for Java](https://console.ng.bluemix.net/catalog/starters/liberty-for-java) runtime gestito dall'implementazione IBM Bluemix CloudFoundry.

4. **CaaS (Container as a Service)** - ambiente del contenitore gestito. Un buon esempio è [Containers on Bluemix](https://console.ng.bluemix.net/catalog/?category=containerImages) di IBM.

5. **IaaS (Infrastructure as a service)** con il runtime Java EE. Un buon esempio è [VM WebSphere Application Server su Bluemix](https://console.ng.bluemix.net/catalog/services/websphere-application-server) da IBM.

Questo è un riepilogo dei pro e dei contro di ogni scelta di architettura dalla **prospettiva di un utente finale** che sviluppa e utilizza le applicazioni su questi runtime differenti:


| Argomento | (1) FaaS OpenWhisk | (2) RYO OpenWhisk | (3) PaaS | (4) CaaS | (5) IaaS+Java EE |
| --- | --- | --- | --- | --- | --- |
|	Unità dell'applicazione	|	Funzione singola (normalmente un piccolo blocco di codice in JavaScript, in Swift o nel contenitore Docker) - può essere inferiore a 1 Kb ma anche più grande. Normalmente non più di pochi Kb.	|	Come la colonna (1)	|	A seconda del runtime utilizzato - potrebbe essere un file EAR o WAR o un altro bundle dell'applicazione specifico per il linguaggio, di solito relativamente grande nella dimensione - Kb o anche Mb con molti servizi in un bundle ma può essere piccolo quanto un singolo servizio.	|	Il contenitore Docker è l'unità di distribuzione.	|	VM con App Server con il file EAR o WAR e altre dipendenze - normalmente la dimensione è in Gb.	|
|	Footprint della risorsa	|	L'utente finale non paga o si interessa della memoria, della CPU o di altre risorse. Visto che l'azione ha alcuni footprint l'utente non se ne deve preoccupare.	|	Alto. L'utente finale deve prima eseguire il provisioning dell'ambiente IaaS e solo dopo installare e configurare OpenWhisk con esso	|	Piccolo. L'utente finale paga per la memoria e la CPU delle applicazioni in esecuzione, ma non paga nulla per le applicazioni che non sono in esecuzione.	|	Da piccolo a medio	|	Alto. L'utente finale deve pagare per l'archiviazione disco, la memoria, le CPU e per gli altri possibili componenti quando l'applicazione è in esecuzione. Quando viene arrestato vengono addebitati solo i costi di archiviazione.	|
|	Installazione e configurazione	|	Nessuna richiesta	|	Difficile - tutto eseguito dall'utente finale	|	Nessuna richiesta	|	Moderata - strumenti mgmt del contenitore, hw, rete, SO forniti dal fornitore di CaaS, immagini, connettività e istanze dall'utente finale	|	Difficile - hw, rete, SO e installazione di Java EE iniziale forniti dal fornitore, ulteriore configurazione, clustering e scalabilità dall'utente finale	|
|	Tempo di provisioning	|	Millisecondi	|	Vedi le colonne (4) e (5)	|	Minuti	|	Minuti	|	Ore	|
|	Gestione in corso	|	Nessuno	|	Difficile	|	Nessuno	|	Moderata	|	Difficile	|
|	Scaling elastico	|	Ogni azione è sempre istantaneamente e intrinsecamente ridimensionata a seconda del caricamento. Non c'è bisogno di eseguire il provisioning delle VM o delle altre risorse in anticipo	|	Non fornito - l'utente finale deve fornire la capacità di calcolo su IaaS e gestire il ridimensionamento delle VM. Una volta ridimensionate le VM, OpenWhisk ridimensionerà l'azione automaticamente ma deve essere già stato eseguito il provisioning delle risorse in anticipo	|	Automatico, ma il ridimensionamento è lento. All'inizio di un picco di diversi minuti, gli utenti potrebbero dover attendere il completamento dell'azione di ridimensionamento. Il ridimensionamento automatico richiede un'attenta ottimizzazione	|	Automatico, ma il ridimensionamento è lento. All'inizio di un picco di diversi minuti, gli utenti potrebbero dover attendere il completamento dell'azione di ridimensionamento. Il ridimensionamento automatico richiede un'attenta ottimizzazione	|	Non fornito	|
|	Pianificazione della capacità	|	Non necessario. FaaS fornirà automaticamente tutta la capacità necessaria	|	È necessario eseguire il provisioning di abbastanza capacità in anticipo o eseguire lo script	|	È necessario pianificare una parte della capacità ma vengono forniti alcuni incrementi della capacità automatici	|	È necessario pianificare una parte della capacità ma vengono forniti alcuni incrementi della capacità automatici	|	Occorre fornire staticamente la capacità sufficiente per gestire i picchi del carico di lavoro	|
|	Stato e connessioni persistenti	|	Molto limitato - non può conservare la connessione persistente, con l'eccezione di alcuni casi di memorizzazione in cache del contenitore. Generalmente lo stato deve essere conservato nella risorsa esterna	|	Come la colonna (1)	|	Supportato - può mantenere una connessione o un socket aperti per molto tempo, può archiviare nella memoria tra le chiamate	|	Supportato - può mantenere una connessione o un socket aperti per molto tempo, può archiviare nella memoria tra le chiamate	|	Supportato - può mantenere una connessione o un socket aperti per molto tempo, può archiviare nella memoria tra le chiamate	|
|	Manutenzione	|	Non richiesta - l'intero stack viene gestito da IBM	|	Significativa - a seconda dell'ambiente di destinazione, l'utente deve eseguire il provisioning dell'hw, della rete, del SO, dell'archiviazione, del DB, installare e conservare OpenWhisk, ecc.	|	Non richiesta - l'intero stack viene gestito dal fornitore	|	Significativo - l'utente deve creare e gestire le immagini personalizzate, distribuire e gestire i contenitori, le connessioni tra i contenitori, ecc.	|	Significativa - l'utente deve allocare le VM, gestire e ridimensionare i server Java EE singolarmente	|
|	Elevata disponibilità (HA) e Ripristino di emergenza (DR)	|	Intrinseco / nessun costo aggiuntivo	|	RYO (Roll your own) 	|	Disponibili ma con costi aggiuntivi	|	I contenitori in errore possono essere automaticamente riavviati	|	Disponibili ma con costi aggiuntivi, semi automatici. Le VM possono avere esito negativo automaticamente	|
|	Sicurezza	|	Fornita dal fornitore	|	RYO (Roll your own)	|	Mix di RYO e fornita dal fornitore	|	Mix di RYO e fornita dal fornitore	|	RYO (Roll your own)	|
|	Velocità sviluppatore	|	Massima	|	Massima	|	Massima	|	Media	|	Lenta	|
|	Utilizzo risorsa (risorse inattive che devono ancora essere pagate)	|	Le risorse non sono mai inattive poiché vengono richiamate solo quando è presente una richiesta. Quando non è presente un carico di lavoro, non c'è alcuna allocazione della risorsa e senza costi	|	Poiché questa opzione sta utilizzando IaaS o CaaS - si applicano considerazioni simili alla colonne (4) e (5)	|	Alcune risorse possono essere inattive. Il ridimensionamento automatico consente di eliminare le risorse inattive, ma alcune istanze in esecuzione devono essere sempre presenti ed essere utilizzate a meno del 50% della loro capacità. Le istanze arrestate non costano nulla.	|	Simile alla colonna (3)	|	Alcune risorse possono essere inattive. Il ridimensionamento automatico non è supportato. Alcune istanze in esecuzione devono essere sempre presenti ed essere utilizzate a meno del 50% della loro capacità. Le istanza arrestate possono avere dei costi di archiviazione	|
|	Maturità	|	Maturità anticipata	|	Maturità anticipata	|	Maturità anticipata	|	Maturità moderata	|	Molto matura	|
|	Limiti delle risorse	|	[Esistono alcuni limiti](./openwhisk_reference.html#openwhisk_syslimits)	|	A seconda delle risorse allocate	|	No	|	No	|	No	|
|	Latenza per i servizi utilizzati raramente	|	Le richieste rare possono inizialmente necessitare di alcuni secondi per il tempo di risposta ma saranno in un intervallo di ms per le richieste seguenti	|	Dipende	|	Molto bassa	|	Molto bassa	|	Molto bassa - assumendo che il sistema abbia abbastanza risorse	|
|	Tipo di punto chiave dell'applicazione	|	Elaborazione evento, IoT, backend mobile, microservizi. Sicuramente non le applicazioni monolitiche. Consulta [casi di utilizzo](./openwhisk_use_cases.html)	|	Come la colonna (1), ma quando l'utente desidera eseguire l'esecuzione su un cloud non IBM o in loco.	|	Applicazioni web con carico di lavoro 24x7, servizi di stato che devono mantenere la connessione aperta per lunghi periodi di tempo. Può essere utilizzato per eseguire microservizi o applicazioni monolitiche	|	Ben progettato per le applicazioni dei microservizi	|	Applicazioni dell'ambiente tradizionale migrate da in loco al cloud. Più indicato per le applicazioni monolitiche	|
|	Fatturazione e costi della granularità	|	[Per blocchi di 100 millisecondi](https://console.ng.bluemix.net/openwhisk/learn/pricing)	|	A seconda dell'implementazione - se sta utilizzando IaaS o CaaS, si applicano considerazioni simili - vedi colonne (4) e (5)	|	Normalmente addebitato per ora (raramente al minuto) per il bundle delle risorse (CPU + memoria + spazio disco)	|	Simile alla colonna (3)	|	Simile alla colonna (3)	|
|	TCO (Total Cost of Ownership)	|	Per le applicazioni di punto chiave è probabile che l'ordine di grandezza dei costi sia inferiore alle alternative. Poiché le risorse vengono ridimensionate automaticamente, non si verifica mai un problema di superamento del provisioning	|	Per le distribuzioni cloud è più caro di FaaS OpenWhisk, ma per le distribuzioni in loco può essere più economico delle architetture tradizionali	|	Relativamente basso - l'utente non ha bisogno di eseguire il provisioning o di gestire le risorse e deve solo prestare attenzione alla propria applicazione, ma esistono alcuni livelli di superamento del provisioning in confronto alle senza server	|	Moderato - l'utente deve eseguire il provisioning e gestire i contenitori e l'applicazione, ma esistono alcuni livelli di superamento del provisioning in confronto alle senza server e a PaaS	|	Relativamente alto, ma considerando che la migrazione delle applicazioni legacy nel modello del cloud nativo potrebbe essere proibitivamente cara, questa può essere una scelta praticabile ed economica per tali applicazioni	|
